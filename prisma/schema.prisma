datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client"
  output   = "./generated/prisma"
}

// User model — authenticated users via Neon Auth
model User {
  id            String     @id @default(cuid())
  email         String?    @unique // email from Neon Auth
  emailVerified DateTime?  // null = not verified, timestamp = when verified
  name          String?
  role          UserRole   @default(USER)
  createdAt     DateTime   @default(now())
  feedbacks     Feedback[]
  feedbackVotes FeedbackVote[]
  reports       Report[]
  checkIns      CheckIn[]
}

// Feedback on lines, stops, and vehicles (extensible to ROUTE_PROPOSAL, FEATURE_REQUEST)
model Feedback {
  id        String       @id @default(cuid())
  userId    String
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      FeedbackType
  targetId  String // line shortName (e.g. "205"), stop gtfsId (e.g. "2:BRRS2"), or vehicleNumber (e.g. "3245")
  rating    Int // 1-5 stars
  comment   String? // optional, max 500 chars
  metadata  Json? // optional context: e.g. { "lineContext": "205" } for vehicle feedback
  tags      String[] @default([]) // issue tags: OVERCROWDED, LATE, DIRTY, etc.
  hidden    Boolean  @default(false) // auto-hidden after N reports
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  votes     FeedbackVote[]
  reports   Report[]

  @@unique([userId, type, targetId]) // one rating per user per target (upsert)
  @@index([type, targetId])
  @@index([userId])
}

// Upvote on a feedback review — one per user per review
model FeedbackVote {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  feedbackId String
  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([userId, feedbackId])
  @@index([feedbackId])
}

// Report on a feedback review — one per user per review
model Report {
  id         String       @id @default(cuid())
  feedbackId String
  feedback   Feedback     @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  userId     String
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  reason     ReportReason
  createdAt  DateTime     @default(now())

  @@unique([feedbackId, userId]) // one report per user per feedback
  @@index([feedbackId])
}

// Transit check-in — users check in to a transit mode
model CheckIn {
  id        String      @id @default(cuid())
  userId    String
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  mode      TransitMode
  targetId  String?     // optional: line shortName ("205"), metro line ("D")
  createdAt DateTime    @default(now())
  expiresAt DateTime    // createdAt + 1 hour

  @@index([expiresAt])
  @@index([userId])
}

enum UserRole {
  USER
  ADMIN
}

enum FeedbackType {
  BUS // deprecated alias kept for compat — maps to LINE
  LINE
  STOP
  VEHICLE // feedback on a specific physical bus (by vehicleNumber)
  BIKE_PARK // bike parking stations
  BIKE_LANE // bike lanes (ciclovias)
}

enum ReportReason {
  SPAM
  OFFENSIVE
  MISLEADING
  OTHER
}

enum TransitMode {
  BUS
  METRO
  BIKE
  WALK
  SCOOTER
}
