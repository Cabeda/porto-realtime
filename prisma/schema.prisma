datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client"
  output   = "./generated/prisma"
}

// User model — authenticated users via Neon Auth
model User {
  id              String           @id @default(cuid())
  email           String?          @unique // email from Neon Auth
  emailVerified   DateTime?        // null = not verified, timestamp = when verified
  name            String?
  role            UserRole         @default(USER)
  createdAt       DateTime         @default(now())
  feedbacks       Feedback[]
  feedbackVotes   FeedbackVote[]
  reports         Report[]
  checkIns        CheckIn[]
  proposals       Proposal[]
  proposalVotes   ProposalVote[]
  proposalReports ProposalReport[]
}

// Feedback on lines, stops, and vehicles (extensible to ROUTE_PROPOSAL, FEATURE_REQUEST)
model Feedback {
  id        String       @id @default(cuid())
  userId    String
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      FeedbackType
  targetId  String // line shortName (e.g. "205"), stop gtfsId (e.g. "2:BRRS2"), or vehicleNumber (e.g. "3245")
  rating    Int // 1-5 stars
  comment   String? // optional, max 500 chars
  metadata  Json? // optional context: e.g. { "lineContext": "205" } for vehicle feedback
  tags      String[] @default([]) // issue tags: OVERCROWDED, LATE, DIRTY, etc.
  hidden    Boolean  @default(false) // auto-hidden after N reports
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  votes     FeedbackVote[]
  reports   Report[]

  @@unique([userId, type, targetId]) // one rating per user per target (upsert)
  @@index([type, targetId])
  @@index([userId])
}

// Upvote on a feedback review — one per user per review
model FeedbackVote {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  feedbackId String
  feedback   Feedback @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([userId, feedbackId])
  @@index([feedbackId])
}

// Report on a feedback review — one per user per review
model Report {
  id         String       @id @default(cuid())
  feedbackId String
  feedback   Feedback     @relation(fields: [feedbackId], references: [id], onDelete: Cascade)
  userId     String
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  reason     ReportReason
  createdAt  DateTime     @default(now())

  @@unique([feedbackId, userId]) // one report per user per feedback
  @@index([feedbackId])
}

// Transit check-in — users check in to a transit mode
// userId is optional to support anonymous check-ins (GDPR-friendly)
// lat/lon represent the target infrastructure location (bus stop, bike park), NOT user GPS
model CheckIn {
  id        String      @id @default(cuid())
  userId    String?
  user      User?       @relation(fields: [userId], references: [id], onDelete: Cascade)
  mode      TransitMode
  targetId  String?     // optional: line shortName ("205"), metro line ("D")
  lat       Float?      // infrastructure coords (bus stop, bike park); null for user-location check-ins
  lon       Float?
  anonHash  String?     // truncated hash of IP+UA for anonymous rate limiting (not PII)
  createdAt DateTime    @default(now())
  expiresAt DateTime    // createdAt + duration (30min anon, 1h auth)

  @@index([expiresAt])
  @@index([userId])
  @@index([anonHash, createdAt]) // for anonymous rate limiting queries
  @@index([expiresAt, mode, targetId]) // for active check-in aggregation queries
}

enum UserRole {
  USER
  ADMIN
}

enum FeedbackType {
  BUS // deprecated alias kept for compat — maps to LINE
  LINE
  STOP
  VEHICLE // feedback on a specific physical bus (by vehicleNumber)
  BIKE_PARK // bike parking stations
  BIKE_LANE // bike lanes (ciclovias)
}

enum ReportReason {
  SPAM
  OFFENSIVE
  MISLEADING
  OTHER
}

enum TransitMode {
  BUS
  METRO
  BIKE
  WALK
  SCOOTER
}

// --- Proposals: community suggestions for transit improvements ---

enum ProposalType {
  BIKE_LANE    // improve existing or propose new bike lanes
  STOP         // stop improvements (shelter, accessibility, signage)
  LINE         // improve existing or propose new transit lines
}

enum ProposalStatus {
  OPEN
  UNDER_REVIEW // enough votes to be considered
  CLOSED
  ARCHIVED
}

// Community proposal for transit improvements
model Proposal {
  id          String           @id @default(cuid())
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        ProposalType
  title       String           // concise summary, max 120 chars
  description String           // detailed justification, max 2000 chars
  targetId    String?          // optional: line shortName, stop gtfsId, bike lane id
  linkUrl     String?          // optional reference URL for more details
  geometry    Json?            // optional GeoJSON geometry (LineString/MultiLineString/Point)
  status      ProposalStatus   @default(OPEN)
  hidden      Boolean          @default(false) // auto-hidden after N reports
  votes       ProposalVote[]
  reports     ProposalReport[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([status])
  @@index([type])
  @@index([userId])
  @@index([type, targetId])
}

// Upvote on a proposal — one per user per proposal
model ProposalVote {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  proposalId String
  proposal   Proposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([userId, proposalId])
  @@index([proposalId])
}

// Report on a proposal — one per user per proposal
model ProposalReport {
  id         String       @id @default(cuid())
  proposalId String
  proposal   Proposal     @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  userId     String
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  reason     ReportReason
  createdAt  DateTime     @default(now())

  @@unique([proposalId, userId]) // one report per user per proposal
  @@index([proposalId])
}
